/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct basic_string<_CharT> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider,
            pub _M_string_length: root::std::basic_string_size_type,
            pub __bindgen_anon_1: root::std::basic_string__bindgen_ty_2<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string__Char_alloc_type = [u8; 0usize];
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::basic_string__Char_alloc_type;
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_reference = [u8; 0usize];
        pub type basic_string_const_reference = [u8; 0usize];
        pub type basic_string_pointer = [u8; 0usize];
        pub type basic_string_const_pointer = [u8; 0usize];
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::basic_string_const_iterator;
        #[repr(C)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::basic_string_pointer,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub struct basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: root::__BindgenUnionField<*mut _CharT>,
            pub _M_allocated_capacity: root::__BindgenUnionField<root::std::basic_string_size_type>,
            pub bindgen_union_field: u64,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut ::std::os::raw::c_uchar,
            pub __align: root::std::aligned_storage_type__bindgen_ty_1,
            _bindgen_union_align: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_aligned_storage_type() {
            assert_eq!(
                ::std::mem::size_of::<aligned_storage_type>(),
                8usize,
                concat!("Size of: ", stringify!(aligned_storage_type))
            );
            assert_eq!(
                ::std::mem::align_of::<aligned_storage_type>(),
                8usize,
                concat!("Alignment of ", stringify!(aligned_storage_type))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = root::std::__undefined;
        pub type __get_first_arg_t = root::std::__get_first_arg;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = root::std::__detected_or_t;
        pub type pointer_traits_difference_type = root::std::__detected_or_t;
        pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        pub type string = root::std::basic_string<::std::os::raw::c_char>;
        pub type streamoff = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        pub type streampos = root::std::fpos<root::mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_istream {
            pub _address: u8,
        }
        pub type istream = root::std::basic_istream;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple__TC2 {
            pub _address: u8,
        }
        pub type tuple__TCC = u8;
        pub type tuple__TMC = u8;
        pub type tuple__TMCT = u8;
        pub type tuple__TNTC = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uniq_ptr_impl {
            pub _M_t: root::std::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uniq_ptr_impl__Ptr {
            pub _address: u8,
        }
        pub type __uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
        pub type __uniq_ptr_impl__DeleterConstraint = u8;
        pub type __uniq_ptr_impl_pointer = root::std::__uniq_ptr_impl__Ptr;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr {
            pub _M_t: root::std::__uniq_ptr_impl,
        }
        pub type unique_ptr__DeleterConstraint = root::std::__uniq_ptr_impl;
        pub type unique_ptr_pointer = root::std::__uniq_ptr_impl;
        pub type unique_ptr_element_type<_Tp> = _Tp;
        pub type unique_ptr_deleter_type<_Dp> = _Dp;
        pub type unique_ptr___safe_conversion_up = root::std::__and_;
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut root::std::vector,
            pub __buf: u8,
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: root::__mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    pub type mbstate_t = root::__mbstate_t;
    pub mod sentencepiece {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SentencePieceText {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NBestSentencePieceText {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ModelInterface {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ModelProto {
            _unused: [u8; 0],
        }
        pub mod normalizer {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Normalizer {
                _unused: [u8; 0],
            }
        }
        pub mod util {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod error {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub const Code_OK: root::sentencepiece::util::error::Code = 0;
                pub const Code_CANCELLED: root::sentencepiece::util::error::Code = 1;
                pub const Code_UNKNOWN: root::sentencepiece::util::error::Code = 2;
                pub const Code_INVALID_ARGUMENT: root::sentencepiece::util::error::Code = 3;
                pub const Code_DEADLINE_EXCEEDED: root::sentencepiece::util::error::Code = 4;
                pub const Code_NOT_FOUND: root::sentencepiece::util::error::Code = 5;
                pub const Code_ALREADY_EXISTS: root::sentencepiece::util::error::Code = 6;
                pub const Code_PERMISSION_DENIED: root::sentencepiece::util::error::Code = 7;
                pub const Code_UNAUTHENTICATED: root::sentencepiece::util::error::Code = 16;
                pub const Code_RESOURCE_EXHAUSTED: root::sentencepiece::util::error::Code = 8;
                pub const Code_FAILED_PRECONDITION: root::sentencepiece::util::error::Code = 9;
                pub const Code_ABORTED: root::sentencepiece::util::error::Code = 10;
                pub const Code_OUT_OF_RANGE: root::sentencepiece::util::error::Code = 11;
                pub const Code_UNIMPLEMENTED: root::sentencepiece::util::error::Code = 12;
                pub const Code_INTERNAL: root::sentencepiece::util::error::Code = 13;
                pub const Code_UNAVAILABLE: root::sentencepiece::util::error::Code = 14;
                pub const Code_DATA_LOSS: root::sentencepiece::util::error::Code = 15;
                pub type Code = u32;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Status {
                pub rep_: root::std::unique_ptr,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Status_Rep {
                _unused: [u8; 0],
            }
            #[test]
            fn bindgen_test_layout_Status() {
                assert_eq!(
                    ::std::mem::size_of::<Status>(),
                    8usize,
                    concat!("Size of: ", stringify!(Status))
                );
                assert_eq!(
                    ::std::mem::align_of::<Status>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Status))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Status>())).rep_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Status),
                        "::",
                        stringify!(rep_)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6Status17set_error_messageEPKc"]
                pub fn Status_set_error_message(
                    this: *mut root::sentencepiece::util::Status,
                    str: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK13sentencepiece4util6Status13error_messageEv"]
                pub fn Status_error_message(
                    this: *const root::sentencepiece::util::Status,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK13sentencepiece4util6Status4codeEv"]
                pub fn Status_code(
                    this: *const root::sentencepiece::util::Status,
                ) -> root::sentencepiece::util::error::Code;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK13sentencepiece4util6Status8ToStringB5cxx11Ev"]
                pub fn Status_ToString(
                    this: *const root::sentencepiece::util::Status,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6Status11IgnoreErrorEv"]
                pub fn Status_IgnoreError(this: *mut root::sentencepiece::util::Status);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6StatusC1Ev"]
                pub fn Status_Status(this: *mut root::sentencepiece::util::Status);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6StatusC1ENS0_5error4CodeEPKc"]
                pub fn Status_Status1(
                    this: *mut root::sentencepiece::util::Status,
                    code: root::sentencepiece::util::error::Code,
                    error_message: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6StatusC1ENS0_5error4CodeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn Status_Status2(
                    this: *mut root::sentencepiece::util::Status,
                    code: root::sentencepiece::util::error::Code,
                    error_message: *const root::std::string,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6StatusC1ERKS1_"]
                pub fn Status_Status3(
                    this: *mut root::sentencepiece::util::Status,
                    s: *const root::sentencepiece::util::Status,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN13sentencepiece4util6StatusD1Ev"]
                pub fn Status_Status_destructor(this: *mut root::sentencepiece::util::Status);
            }
            impl Status {
                #[inline]
                pub unsafe fn set_error_message(&mut self, str: *const ::std::os::raw::c_char) {
                    Status_set_error_message(self, str)
                }
                #[inline]
                pub unsafe fn error_message(&self) -> *const ::std::os::raw::c_char {
                    Status_error_message(self)
                }
                #[inline]
                pub unsafe fn code(&self) -> root::sentencepiece::util::error::Code {
                    Status_code(self)
                }
                #[inline]
                pub unsafe fn ToString(&self) -> root::std::string {
                    Status_ToString(self)
                }
                #[inline]
                pub unsafe fn IgnoreError(&mut self) {
                    Status_IgnoreError(self)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    Status_Status(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    code: root::sentencepiece::util::error::Code,
                    error_message: *const ::std::os::raw::c_char,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    Status_Status1(__bindgen_tmp.as_mut_ptr(), code, error_message);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new2(
                    code: root::sentencepiece::util::error::Code,
                    error_message: *const root::std::string,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    Status_Status2(__bindgen_tmp.as_mut_ptr(), code, error_message);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new3(s: *const root::sentencepiece::util::Status) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    Status_Status3(__bindgen_tmp.as_mut_ptr(), s);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    Status_Status_destructor(self)
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct min_string_view {
                pub ptr_: *const ::std::os::raw::c_char,
                pub length_: usize,
            }
            #[test]
            fn bindgen_test_layout_min_string_view() {
                assert_eq!(
                    ::std::mem::size_of::<min_string_view>(),
                    16usize,
                    concat!("Size of: ", stringify!(min_string_view))
                );
                assert_eq!(
                    ::std::mem::align_of::<min_string_view>(),
                    8usize,
                    concat!("Alignment of ", stringify!(min_string_view))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<min_string_view>())).ptr_ as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(min_string_view),
                        "::",
                        stringify!(ptr_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<min_string_view>())).length_ as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(min_string_view),
                        "::",
                        stringify!(length_)
                    )
                );
            }
            pub type bytes = root::std::string;
        }
        #[repr(C)]
        pub struct SentencePieceProcessor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct SentencePieceProcessor {
            pub vtable_: *const SentencePieceProcessor__bindgen_vtable,
            pub model_: root::std::unique_ptr,
            pub normalizer_: root::std::unique_ptr,
            pub model_proto_: root::std::unique_ptr,
            pub encode_extra_options_: root::std::vector,
            pub decode_extra_options_: root::std::vector,
        }
        pub const SentencePieceProcessor_ExtraOption_REVERSE:
            root::sentencepiece::SentencePieceProcessor_ExtraOption = 0;
        pub const SentencePieceProcessor_ExtraOption_BOS:
            root::sentencepiece::SentencePieceProcessor_ExtraOption = 1;
        pub const SentencePieceProcessor_ExtraOption_EOS:
            root::sentencepiece::SentencePieceProcessor_ExtraOption = 2;
        pub type SentencePieceProcessor_ExtraOption = u32;
        #[test]
        fn bindgen_test_layout_SentencePieceProcessor() {
            assert_eq!(
                ::std::mem::size_of::<SentencePieceProcessor>(),
                80usize,
                concat!("Size of: ", stringify!(SentencePieceProcessor))
            );
            assert_eq!(
                ::std::mem::align_of::<SentencePieceProcessor>(),
                8usize,
                concat!("Alignment of ", stringify!(SentencePieceProcessor))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SentencePieceProcessor>())).model_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SentencePieceProcessor),
                    "::",
                    stringify!(model_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SentencePieceProcessor>())).normalizer_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SentencePieceProcessor),
                    "::",
                    stringify!(normalizer_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SentencePieceProcessor>())).model_proto_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SentencePieceProcessor),
                    "::",
                    stringify!(model_proto_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SentencePieceProcessor>())).encode_extra_options_
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SentencePieceProcessor),
                    "::",
                    stringify!(encode_extra_options_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SentencePieceProcessor>())).decode_extra_options_
                        as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SentencePieceProcessor),
                    "::",
                    stringify!(decode_extra_options_)
                )
            );
        }
        extern "C" {
            #[doc = ""]
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor8SetModelEOSt10unique_ptrINS_14ModelInterfaceESt14default_deleteIS2_EE"]
            pub fn SentencePieceProcessor_SetModel(
                this: *mut root::sentencepiece::SentencePieceProcessor,
                model: *mut root::std::unique_ptr,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor13SetNormalizerEOSt10unique_ptrINS_10normalizer10NormalizerESt14default_deleteIS3_EE"]
            pub fn SentencePieceProcessor_SetNormalizer(
                this: *mut root::sentencepiece::SentencePieceProcessor,
                normalizer: *mut root::std::unique_ptr,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor11model_protoEv"]
            pub fn SentencePieceProcessor_model_proto(
                this: *const root::sentencepiece::SentencePieceProcessor,
            ) -> *const root::sentencepiece::ModelProto;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessorC1Ev"]
            pub fn SentencePieceProcessor_SentencePieceProcessor(
                this: *mut root::sentencepiece::SentencePieceProcessor,
            );
        }
        impl SentencePieceProcessor {
            #[inline]
            pub unsafe fn SetModel(&mut self, model: *mut root::std::unique_ptr) {
                SentencePieceProcessor_SetModel(self, model)
            }
            #[inline]
            pub unsafe fn SetNormalizer(&mut self, normalizer: *mut root::std::unique_ptr) {
                SentencePieceProcessor_SetNormalizer(self, normalizer)
            }
            #[inline]
            pub unsafe fn model_proto(&self) -> *const root::sentencepiece::ModelProto {
                SentencePieceProcessor_model_proto(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SentencePieceProcessor_SentencePieceProcessor(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessorD1Ev"]
            pub fn SentencePieceProcessor_SentencePieceProcessor_destructor(
                this: *mut root::sentencepiece::SentencePieceProcessor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor4LoadENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_Load(
                this: *mut ::std::os::raw::c_void,
                filename: root::sentencepiece::util::min_string_view,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor9LoadOrDieENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_LoadOrDie(
                this: *mut ::std::os::raw::c_void,
                filename: root::sentencepiece::util::min_string_view,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor4LoadEPSi"]
            pub fn SentencePieceProcessor_Load1(
                this: *mut ::std::os::raw::c_void,
                is: *mut root::std::istream,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor4LoadERKNS_10ModelProtoE"]
            pub fn SentencePieceProcessor_Load2(
                this: *mut ::std::os::raw::c_void,
                model_proto: *const root::sentencepiece::ModelProto,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor4LoadEOSt10unique_ptrINS_10ModelProtoESt14default_deleteIS2_EE"]
            pub fn SentencePieceProcessor_Load3(
                this: *mut ::std::os::raw::c_void,
                model_proto: *mut root::std::unique_ptr,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor23LoadFromSerializedProtoENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_LoadFromSerializedProto(
                this: *mut ::std::os::raw::c_void,
                serialized: root::sentencepiece::util::min_string_view,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6statusEv"]
            pub fn SentencePieceProcessor_status(
                this: *mut ::std::os::raw::c_void,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor21SetEncodeExtraOptionsENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_SetEncodeExtraOptions(
                this: *mut ::std::os::raw::c_void,
                extra_option: root::sentencepiece::util::min_string_view,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor21SetDecodeExtraOptionsENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_SetDecodeExtraOptions(
                this: *mut ::std::os::raw::c_void,
                extra_option: root::sentencepiece::util::min_string_view,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor13SetVocabularyERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EE"]
            pub fn SentencePieceProcessor_SetVocabulary(
                this: *mut ::std::os::raw::c_void,
                valid_vocab: *const root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor15ResetVocabularyEv"]
            pub fn SentencePieceProcessor_ResetVocabulary(
                this: *mut ::std::os::raw::c_void,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN13sentencepiece22SentencePieceProcessor14LoadVocabularyENS_4util15min_string_viewEi"]
            pub fn SentencePieceProcessor_LoadVocabulary(
                this: *mut ::std::os::raw::c_void,
                filename: root::sentencepiece::util::min_string_view,
                threshold: ::std::os::raw::c_int,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[doc = ""]
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6EncodeENS_4util15min_string_viewEPSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EE"]
            pub fn SentencePieceProcessor_Encode(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                pieces: *mut root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6EncodeENS_4util15min_string_viewEPSt6vectorIiSaIiEE"]
            pub fn SentencePieceProcessor_Encode1(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                ids: *mut root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6DecodeERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EEPS7_"]
            pub fn SentencePieceProcessor_Decode(
                this: *mut ::std::os::raw::c_void,
                pieces: *const root::std::vector,
                detokenized: *mut root::std::string,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6DecodeERKSt6vectorIiSaIiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn SentencePieceProcessor_Decode1(
                this: *mut ::std::os::raw::c_void,
                ids: *const root::std::vector,
                detokenized: *mut root::std::string,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[doc = ""]
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor11NBestEncodeENS_4util15min_string_viewEiPSt6vectorIS3_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EESaISB_EE"]
            pub fn SentencePieceProcessor_NBestEncode(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                pieces: *mut root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor11NBestEncodeENS_4util15min_string_viewEiPSt6vectorIS3_IiSaIiEESaIS5_EE"]
            pub fn SentencePieceProcessor_NBestEncode1(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                ids: *mut root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[doc = ""]
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor12SampleEncodeENS_4util15min_string_viewEifPSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EE"]
            pub fn SentencePieceProcessor_SampleEncode(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                alpha: f32,
                pieces: *mut root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor12SampleEncodeENS_4util15min_string_viewEifPSt6vectorIiSaIiEE"]
            pub fn SentencePieceProcessor_SampleEncode1(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                alpha: f32,
                ids: *mut root::std::vector,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[doc = ""]
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6EncodeENS_4util15min_string_viewEPNS_17SentencePieceTextE"]
            pub fn SentencePieceProcessor_Encode2(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                spt: *mut root::sentencepiece::SentencePieceText,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor11NBestEncodeENS_4util15min_string_viewEiPNS_22NBestSentencePieceTextE"]
            pub fn SentencePieceProcessor_NBestEncode2(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                nbest_spt: *mut root::sentencepiece::NBestSentencePieceText,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor12SampleEncodeENS_4util15min_string_viewEifPNS_17SentencePieceTextE"]
            pub fn SentencePieceProcessor_SampleEncode2(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                alpha: f32,
                spt: *mut root::sentencepiece::SentencePieceText,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6DecodeERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EEPNS_17SentencePieceTextE"]
            pub fn SentencePieceProcessor_Decode2(
                this: *mut ::std::os::raw::c_void,
                pieces: *const root::std::vector,
                spt: *mut root::sentencepiece::SentencePieceText,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6DecodeERKSt6vectorIiSaIiEEPNS_17SentencePieceTextE"]
            pub fn SentencePieceProcessor_Decode3(
                this: *mut ::std::os::raw::c_void,
                ids: *const root::std::vector,
                spt: *mut root::sentencepiece::SentencePieceText,
            ) -> root::sentencepiece::util::Status;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor23EncodeAsSerializedProtoB5cxx11ENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_EncodeAsSerializedProto(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
            ) -> root::sentencepiece::util::bytes;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor29SampleEncodeAsSerializedProtoB5cxx11ENS_4util15min_string_viewEif"]
            pub fn SentencePieceProcessor_SampleEncodeAsSerializedProto(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
                alpha: f32,
            ) -> root::sentencepiece::util::bytes;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor28NBestEncodeAsSerializedProtoB5cxx11ENS_4util15min_string_viewEi"]
            pub fn SentencePieceProcessor_NBestEncodeAsSerializedProto(
                this: *mut ::std::os::raw::c_void,
                input: root::sentencepiece::util::min_string_view,
                nbest_size: ::std::os::raw::c_int,
            ) -> root::sentencepiece::util::bytes;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor29DecodePiecesAsSerializedProtoERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EE"]
            pub fn SentencePieceProcessor_DecodePiecesAsSerializedProto(
                this: *mut ::std::os::raw::c_void,
                pieces: *const root::std::vector,
            ) -> root::sentencepiece::util::bytes;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor26DecodeIdsAsSerializedProtoB5cxx11ERKSt6vectorIiSaIiEE"]
            pub fn SentencePieceProcessor_DecodeIdsAsSerializedProto(
                this: *mut ::std::os::raw::c_void,
                ids: *const root::std::vector,
            ) -> root::sentencepiece::util::bytes;
        }
        extern "C" {
            #[doc = ""]
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor12GetPieceSizeEv"]
            pub fn SentencePieceProcessor_GetPieceSize(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor9PieceToIdENS_4util15min_string_viewE"]
            pub fn SentencePieceProcessor_PieceToId(
                this: *mut ::std::os::raw::c_void,
                piece: root::sentencepiece::util::min_string_view,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor9IdToPieceB5cxx11Ei"]
            pub fn SentencePieceProcessor_IdToPiece(
                this: *mut ::std::os::raw::c_void,
                id: ::std::os::raw::c_int,
            ) -> *const root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor8GetScoreEi"]
            pub fn SentencePieceProcessor_GetScore(
                this: *mut ::std::os::raw::c_void,
                id: ::std::os::raw::c_int,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor9IsUnknownEi"]
            pub fn SentencePieceProcessor_IsUnknown(
                this: *mut ::std::os::raw::c_void,
                id: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor9IsControlEi"]
            pub fn SentencePieceProcessor_IsControl(
                this: *mut ::std::os::raw::c_void,
                id: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor8IsUnusedEi"]
            pub fn SentencePieceProcessor_IsUnused(
                this: *mut ::std::os::raw::c_void,
                id: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6unk_idEv"]
            pub fn SentencePieceProcessor_unk_id(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6bos_idEv"]
            pub fn SentencePieceProcessor_bos_id(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6eos_idEv"]
            pub fn SentencePieceProcessor_eos_id(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK13sentencepiece22SentencePieceProcessor6pad_idEv"]
            pub fn SentencePieceProcessor_pad_id(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_Status_Rep_default_delete_open1_Status_Rep_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_Status_Rep_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_ModelProto_default_delete_open1_ModelProto_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_ModelProto_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_vector_open1_string_allocator_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_close2_close1_allocator_open1_vector_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_allocator_open3_basic_string_open4_char_char_traits_open5_char_close5_allocator_open5_char_close5_close4_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_4(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_vector_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_allocator_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_5(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_4(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_6(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_vector_open1_int_allocator_open2_int_close2_close1_allocator_open1_vector_open2_int_allocator_open3_int_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_vector_open1_int_allocator_open2_int_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation_4(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_5(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_7(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation_5(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_6(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_8(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation_6(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_7(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_9(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_int_allocator_open1_int_close1_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_ModelInterface_default_delete_open1_ModelInterface_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_ModelInterface_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_Normalizer_default_delete_open1_Normalizer_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_Normalizer_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_ModelInterface_default_delete_open1_ModelInterface_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_ModelInterface_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_Normalizer_default_delete_open1_Normalizer_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_Normalizer_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_ModelProto_default_delete_open1_ModelProto_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_ModelProto_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_SentencePieceProcessor_ExtraOption_allocator_open1_SentencePieceProcessor_ExtraOption_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_SentencePieceProcessor_ExtraOption_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_SentencePieceProcessor_ExtraOption_allocator_open1_SentencePieceProcessor_ExtraOption_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_SentencePieceProcessor_ExtraOption_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
}
